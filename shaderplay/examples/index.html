<!doctype html>
<html lang="eng">
	<head>
		<title>rollersonly.com</title>
		<link type="text/css" rel="stylesheet" href="../examples/style.css">
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="https://cdn.rawgit.com/mrdoob/three.js/master/examples/js/loaders/GLTFLoader.js"></script> -->
		<!-- 		<script src="three/examples/jsm/loaders/GLTFLoader.js"></script>-->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script> 
	</head>
	<body>
		<!-- <script type="application/javascript" src="../build/three.module.js"></script> -->
		<!-- <script type="module" src="script.js"></script> -->
		<script type="module">
			import * as THREE from '../build/three.module.js';

			import {
			    OrbitControls
			} from '../examples/jsm/controls/OrbitControls.js'

			const scene = new THREE.Scene()
			scene.background = new THREE.Color(0x87ceeb)

			const ambientLight = new THREE.AmbientLight(0xaaaaaa);
			scene.add(ambientLight);

			// lighting for some reason
			const light1 = new THREE.PointLight();
			light1.position.set(10, 10, 10)
			light1.castShadow = true
			light1.shadow.bias = -0.0002
			light1.shadow.mapSize.height = 1024
			light1.shadow.mapSize.width = 1024
			scene.add(light1);

			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100)
			camera.position.set(1.75, 1.75, 3.5)

			// making a rendered
			const renderer = new THREE.WebGLRenderer()
			renderer.setSize(window.innerWidth, window.innerHeight)
			renderer.shadowMap.enabled = true
			document.body.appendChild(renderer.domElement)

			// using built in controls of three.js for movement
			const orbitControls = new OrbitControls(camera, renderer.domElement)
			orbitControls.dampingFactor = .1
			orbitControls.enableDamping = true

			const texture = new THREE.TextureLoader().load("../cube_map/circle_map.jpg");

			texture.mapping = THREE.EquirectangularReflectionMapping;
			texture.encoding = THREE.sRGBEncoding;

			scene.background = texture;


			// resizing window reset trash
			window.addEventListener('resize', onWindowResize, false)

			function onWindowResize() {
			    camera.aspect = window.innerWidth / window.innerHeight
			    camera.updateProjectionMatrix()
			    renderer.setSize(window.innerWidth, window.innerHeight)
			    render()
			}

			// SHADER CODE
			const BasicShader = {

				uniforms: { 
					cubemap: {
						type: 't',
						value: null
					},
					cameraPosition: {
						type: 'v3',
						value: null
					}
				},

				vertexShader: /* glsl */ `
					uniform samplerCube envMap;
					varying vec3 fNormal;
					varying vec3 fPosition;
					varying float intensity;
					varying vec3 envSample;

					const vec3 light = vec3(1.0, 1.0, 1.0);
					const vec3 ambient = vec3(0.01, 0.01, 0.01);

					void main() {

						fNormal = normalize(normalMatrix * normal);

			  			vec4 pos = modelViewMatrix * vec4(position, 1.0);
			  			fPosition = pos.xyz;

			  			vec3 worldPosition = ( modelMatrix * vec4( position, 1.0 )).xyz;
			  			vec3 vertexToEye = normalize( worldPosition - cameraPosition );
			  			vec3 lightDir = normalize(light - pos.xyz);

			  			float diffuse = dot(lightDir, fNormal);

			  			intensity = diffuse + dot(diffuse * 2.0 * fNormal - lightDir, vertexToEye);

			  			if (intensity < 0.0) {
			    			intensity = 0.0;
			  			}

			  			envSample = reflect( vertexToEye, fNormal );

			  			gl_Position = projectionMatrix * pos;		
			  		}`,

				fragmentShader: /* glsl */ `
					uniform samplerCube cubemap;

					varying vec3 fPosition;
					varying float intensity;
					varying vec3 envSample;

					void main() {
						vec3 outcolor = textureCube(cubemap, envSample).rgb;

			  			gl_FragColor = vec4(outcolor, 1.0);
					}`
			};

			const cubeRenderTarget1 =
			    new THREE.WebGLCubeRenderTarget(128, {
			        format: THREE.RGBFormat,
			        generateMipmaps: true,
			        minFilter: THREE.LinearMipmapLinearFilter
			    });

			const cubeCamera1 = new THREE.CubeCamera(.1, 1000, cubeRenderTarget1);

			const pivot1 = new THREE.Object3D();
			scene.add(pivot1);

			BasicShader.uniforms.cubemap.value = cubeRenderTarget1.texture;
			BasicShader.uniforms.cameraPosition.value = camera.

			const material1 = new THREE.MeshPhongMaterial({
			    shininess: 100,
			    color: 0xffffff,
			    specular: 0xffaa00,
			    reflectivity: 0.9,
			    envMap: cubeRenderTarget1.texture
			});

			const ball1 = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), material1);
			ball1.position.set(1, 1.1, 0);
			ball1.castShadow = true;
			ball1.receiveShadow = true;
			ball1.add(cubeCamera1);
			pivot1.add(ball1);


			var animate = function() {
			    requestAnimationFrame(animate)

			    orbitControls.update()

			    render()
			};

			function render() {
			    ball1.visible = false
			    cubeCamera1.update(renderer, scene);
			    ball1.visible = true

			    renderer.render(scene, camera)
			}
			animate();
		</script>
		<!-- <script type="module">
			import * as THREE from '../build/three.module.js';

			import { GLTFLoader } from '../examples/jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';

			// CUBE MAPPING
			let cubemap;
			const r = '/cube_map/scene_';
			const urls = [ r + 'neg_x.jpg', r + 'pos_x.jpg',
						   r + 'neg_y.jpg', r + 'pos_y.jpg',
						   r + 'neg_z.jpg', r + 'pos_z.jpg' ];
			let textureCube = new THREE.CubeTextureLoader().load(urls);
			textureCube.encoding = THREE.sRGBEncoding;

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  			camera.position.set(20, 20, 20);

  			scene.add(new THREE.AxesHelper(20));

			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			let controls = new OrbitControls(camera, renderer.domElement);

			// making test cube camera
			const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 128, {
				format: THREE.RGBFormat,
				generateMipmaps: true,
				minFilter: THREE.LinearMipmapLinearFilter
			});

			const cubeCamera = new THREE.CubeCamera( 0.1, 1000, cubeRenderTarget);

			scene.add( cubeCamera );
			//scene.background = new THREE.Color('grey');
			const BasicShader = {

				uniforms: { 
					cubemap: {
						type: 't',
						value: textureCube
					},
					cameraPosition: {
						type: 'v3',
						value: null
					}
				},

				sphere_uniforms: {
					cubemap: {
						type: 't',
						value: textureCube
					},
					cameraPosition: {
						type: 'v3',
						value: null
					}
				},

				vertexShader: /* glsl */ `
					uniform samplerCube envMap;
					varying vec3 fNormal;
					varying vec3 fPosition;
					varying float intensity;
					varying vec3 envSample;
					varying vec3 square_map;
					const vec3 light = vec3(1.0, 1.0, 1.0);
					const vec3 ambient = vec3(0.01, 0.01, 0.01);
					void main() {
						fNormal = normalize(normalMatrix * normal);
			  			vec4 pos = modelViewMatrix * vec4(position, 1.0);
			  			fPosition = pos.xyz;
			  			vec3 worldPosition = ( modelMatrix * vec4( position, 1.0 )).xyz;
			  			vec3 vertexToEye = normalize( worldPosition - cameraPosition );
			  			vec3 lightDir = normalize(light - pos.xyz);
			  			float diffuse = dot(lightDir, fNormal);
			  			intensity = diffuse + dot(diffuse * 2.0 * fNormal - lightDir, vertexToEye);
			  			if (intensity < 0.0) {
			    			intensity = 0.0;
			  			}
			  			square_map = (projectionMatrix * vec4(position, 1.0)).xyz;
			  			envSample = reflect( vertexToEye, fNormal );
			  			gl_Position = projectionMatrix * pos;		
			  		}`,

				fragmentShader: /* glsl */ `
					uniform samplerCube cubemap;
					varying vec3 fPosition;
					varying float intensity;
					varying vec3 square_map;
					varying vec3 envSample;
					void main() {
						vec3 outcolor = textureCube(cubemap, square_map).rgb;
			  			gl_FragColor = vec4(outcolor, 1.0);
					}`,

				sphereFragmentShader: `
					uniform samplerCube cubemap;
					varying vec3 fPosition;
					varying float intensity;
					varying vec3 square_map;
					varying vec3 envSample;
					void main() {
						vec3 outcolor = textureCube(cubemap, envSample).rgb;
						gl_FragColor = textureCube(cubemap, envSample);
					}`
			};

			let material = new THREE.ShaderMaterial({
				side: THREE.BackSide,
				uniforms: BasicShader.uniforms,
				vertexShader: BasicShader.vertexShader,
				fragmentShader: BasicShader.fragmentShader
			});

			let geometry = new THREE.BoxGeometry( 1000, 1000, 1000 );
			let mesh = new THREE.Mesh( geometry, material );
			scene.add( mesh );

			// let model;
			// const loader = new GLTFLoader();
			// loader.load('../examples/Hydrozoan-jelly.gltf', function(gltf) {
			// 	model = gltf.scene;
  	// 			model.traverse((o) => {
   // 					if (o.isMesh) o.material = shaderMaterial;
  	// 			});
  	// 		 scene.add( model );
			// 	animate();
			// }, undefined, function(error) {
			// 	console.log(error);
			// });
		//  EQUIRECTANGULAR
  		// 	const text_loader = new THREE.TextureLoader();
  		// 	text_loader.load('../cube_map/circle_map.jpg', function(texture) {
  		// 		texture.mapping = THREE.EquirectangularReflectionMapping;
  		// 		texture.encoding = THREE.sRGBEncoding;
  		// 		texture.needsUpdate = true;
  		// 		scene.background = texture;
  		// 		BasicShader.uniforms.envMap = texture;
  		// 		let shaderMaterial = new THREE.ShaderMaterial({
  		// 			uniforms: BasicShader.uniforms,
				// 	vertexShader: BasicShader.vertexShader,
				// 	fragmentShader: BasicShader.fragmentShader
				// });
				// SPHERE MAKING
				// let sphere_material = new THREE.ShaderMaterial({
				// 	uniforms: BasicShader.sphere_uniforms,
				// 	vertexShader: BasicShader.vertexShader,
				// 	fragmentShader: BasicShader.sphereFragmentShader
				// });

				let sphere_material = new THREE.MeshPhongMaterial({
					shininess: 100,
					color: 0xffffff,
					specular: 0xffaa00,
					reflectivity: 0.9,
					envMap: cubeRenderTarget.texture
				});

  				const sphere_geometry = new THREE.SphereGeometry( 1, 32, 32 );
				const sphere = new THREE.Mesh( sphere_geometry, sphere_material );
				sphere.add(cubeCamera);
				scene.add( sphere );
  		// 		animate();
  		// 	});
			function animate() {
				requestAnimationFrame(animate);

				//sphere_material.uniforms.cameraPosition.value = camera.position.clone();

				sphere.visible = false;
				cubeCamera.update(renderer, scene);
				sphere.visible = true;

				console.log("pre cubemap");
				sphere_material.uniforms.cubemap.value = cubeCamera.renderTarget.texture;
				sphere_material.needsUpdate = true;
				//cube.rotation.x += 0.01;
				//cube.rotation.y += 0.01;
				//root.rotation.x += 0.01;
				//model.rotation.y += 0.01
				renderer.render(scene, camera);
			}
			animate();
		</script> -->
	</body>
</html>